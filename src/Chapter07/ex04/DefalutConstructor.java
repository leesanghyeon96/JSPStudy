package Chapter07.ex04;

class A { //클래스에 올 수 있는 것 : 필드 , 생성자, 메소드
	//필드 : 1. 인스턴스 필드 : 객체를 생성해야 호출
	//		2. static 필드 : 클래스명으로 호출
	int m ;
	
	//기본생성자 생략 : 클래스 내부에 다른 생성자가 없을 시 생략
	// A (){}  - 명시를 하지 않으면 생략되어있음
	
	//메소드 
	void work() {
		System.out.println(m);		//값을 할당하지 않았으므로 기본값으로 int = 0
	}
}	//여기까지 class A 블락

class B {
	int m ;
	B(){}		//기본생성자 : 명시
	void work() {
		System.out.println(m);		//값을 할당하지 않았으므로 기본값으로 int = 0
	}
}	// class B 블락

class C{
	int m;
	//기본생성자 생략됨 : 인풋값이 없는 생성자
	//C(){}	: 실행구문에 다른거 넣어도됨
	C(int m){		//생성자 : 인풋값 1개를 받는 생성자  ,  객체를 만들때 생성자를 만들어야한다.
		this.m = m;			// 인풋 매개변수 ==> 실행블락의 변수 ==> 필드의 변수 이름이 모두 동일할 경우
						// this. : 자신의 객체의 필드(필드의 변수라고 선언)
	}
	void work() {
		System.out.println(m);
	}
}



public class DefalutConstructor {

	public static void main(String[] args) {
		// 생성자(Constructor) : 객체를 생성할때 호출
			// 리턴이 없고 클래스 이름과 동일한 메소드(메소드는 리턴값이 있어야한다.)
			//기본 생성자는 생략 가능 : A () {} , 클래스 내부에 다른 생성자가 존재할때 명시를 해줘야 한다.
		
		//1. A 클래스의 객체를 생성하고 메소드 호출 : 기본생성자가 생략됨
		A a = new A();		//new A(); - 기본생성자 호출(생략됨)      a - 객체
		a.work();  // a라는 객체의 work호출 = int m을 호출
		
		//2. B 클래스 : 기본생성자가 명시
		B b = new B();
		b.work();
		
		//3. C 클래스 : 기본생성자가 생략됨, 인풋값을 1개 받는 생성자가 존재
		//C c = new C();  -> 오류발생 : 클래스내에 다른 생성자가 존재하면 기본생성자를 명시해야함
							//그렇지 않으면 오류가 발생함
		 C c1 = new C(3);	//매개변수에 정수값을 넣어 호출 3이 m에 들어가 필드변수에 들어감. 그 후 출력구문에서 출력됨
		 c1.work();
		
		
		
	}

}
